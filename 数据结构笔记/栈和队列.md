# 栈和队列
# 栈和队列
## 3.1 栈和队列的定义和特点
### 3.1.1 栈的定义和特点
定义：

**栈** 是限定仅在表尾进行插入或删除操作的线性表。所以一般称表尾为**栈顶**，表头为**栈底**。 不含元素的空表称为**空栈**。

特点：

先进后出

### 3.1.2 队列的定义和特点
定义：

**队列** 只允许在表的一端插入，而在另外一段删除元素。允许插入的一段称为队尾，允许删除的一端称为队头。

特点：

先进先出

## 3.2 案例引入
### 案例3.1 数制的转换
### 案例3.2 括号匹配的检验
### 案例3.3 表达式求值
### 案例3.4 舞伴问题
## 3.3 栈的表示和操作的实现
### 3.3.1 栈的类型定义

一些基本操作

```
Initstack(&S)    //构造一个空栈
DestoryStack(&S)    //销毁栈S
ClearStack(&S)    //清空栈
StackEmpty(S)    //判断栈是否为空
StackLength(S)    // 返回S的元素个数
GetTop(S)    //返回S的栈顶元素
Push(&S,e)    //插入元素e为新的栈顶元素
Pop(&S,&e)    //提出栈顶元素，用e返回
StackTraverse(S)    //从栈底到栈顶依次对S的每个元素进行访问
```

### 顺序栈的表示和实现

**顺序栈** 是指利用顺序存储结构实现的栈，同时附设top指针指示栈顶元素在顺序栈中的位置，附设base指针指向栈底元素所在的位置。当top = base 时表示空栈。

顺序栈的定义如下：

```
//--------顺序栈的存储结构--------
#define MAXSIZE 100
typedef strust{
    SElemType *base;
    SElemType *top;
    int stacksize;
}SqStack;
```

**说明**

1. 栈底指针base始终指向栈底的位置，如果base的值为NULL，则说明栈结构式不存在的。top的初值指向栈底，每增加一个元素，top加一，删除一个元素top减一，top = base时空栈。
2. stacksize指示栈可以使用的最大容量。

#### 算法3.1 顺序栈的初始化

【算法步骤】

1. 为顺序栈动态分配一个最大容量为MAXSIZE的数组空间，是base指向这段空间的基地址，即栈底。
2. 栈顶指针top初始为base，即空栈
3. stacksize置为栈的最大容量。

【算法描述】

```c
Status InitStack(SqStack &S){//构造一个空栈S
    S.base = new SElemType[MAXSIZE];
    if(!S.basu){//判断是否开辟空间成功
        exit(OVERFLOW);
    }//endif
    S.top = S.base;
    S.stacksize = MAXSIZE;
    return OK;
}
```

#### 几个简单的算法

1. 判断栈是否为空

```c
Status StackEmpty(SqStack S){
    if(S.top = S.base){
        return TURE;
    }else{
        return FALSE;
    }
}
```

2. 求栈的长度

```c
int StackLength(SqStack S){
    return S.top - S.base
}
```

3. 清空顺序栈

```c
Status ClearStack(SqStack S){
    if(S.base){
        S.top = S.base;
    }
    return OK;
}
```

4. 销毁栈

```c
Status DestoryStack(SqStack &S){
    if(S.base){
        delete S.base;
        S.stacksize = 0;
        S.top = S.base = NULL;
    }
    return OK;
}
```

#### 算法3.2 顺序栈的入栈



