# 栈和队列
# 栈和队列
## 3.1 栈和队列的定义和特点
### 3.1.1 栈的定义和特点
定义：

**栈** 是限定仅在表尾进行插入或删除操作的线性表。所以一般称表尾为**栈顶**，表头为**栈底**。 不含元素的空表称为**空栈**。

特点：

先进后出

### 3.1.2 队列的定义和特点
定义：

**队列** 只允许在表的一端插入，而在另外一段删除元素。允许插入的一段称为队尾，允许删除的一端称为队头。

特点：

先进先出

## 3.2 案例引入
### 案例3.1 数制的转换
### 案例3.2 括号匹配的检验
### 案例3.3 表达式求值
### 案例3.4 舞伴问题
## 3.3 栈的表示和操作的实现
### 3.3.1 栈的类型定义

一些基本操作

```
Initstack(&S)    //构造一个空栈
DestoryStack(&S)    //销毁栈S
ClearStack(&S)    //清空栈
StackEmpty(S)    //判断栈是否为空
StackLength(S)    // 返回S的元素个数
GetTop(S)    //返回S的栈顶元素
Push(&S,e)    //插入元素e为新的栈顶元素
Pop(&S,&e)    //提出栈顶元素，用e返回
StackTraverse(S)    //从栈底到栈顶依次对S的每个元素进行访问
```

### 顺序栈的表示和实现

**顺序栈** 是指利用顺序存储结构实现的栈，同时附设top指针指示栈顶元素在顺序栈中的位置，附设base指针指向栈底元素所在的位置。当top = base 时表示空栈。

顺序栈的定义如下：

```
//--------顺序栈的存储结构--------
#define MAXSIZE 100
typedef strust{
    SElemType *base;
    SElemType *top;
    int stacksize;
}SqStack;
```

**说明**

1. 栈底指针base始终指向栈底的位置，如果base的值为NULL，则说明栈结构式不存在的。top的初值指向栈底，每增加一个元素，top加一，删除一个元素top减一，top = base时空栈。
2. stacksize指示栈可以使用的最大容量。

#### 算法3.1 顺序栈的初始化

【算法步骤】

1. 为顺序栈动态分配一个最大容量为MAXSIZE的数组空间，是base指向这段空间的基地址，即栈底。
2. 栈顶指针top初始为base，即空栈
3. stacksize置为栈的最大容量。

【算法描述】

```c
Status InitStack(SqStack &S){//构造一个空栈S
    S.base = new SElemType[MAXSIZE];
    if(!S.basu){//判断是否开辟空间成功
        exit(OVERFLOW);
    }//endif
    S.top = S.base;
    S.stacksize = MAXSIZE;
    return OK;
}
```

#### 几个简单的算法

1. 判断栈是否为空

```c
Status StackEmpty(SqStack S){
    if(S.top = S.base){
        return TURE;
    }else{
        return FALSE;
    }
}
```

2. 求栈的长度

```c
int StackLength(SqStack S){
    return S.top - S.base
}
```

3. 清空顺序栈

```c
Status ClearStack(SqStack S){
    if(S.base){
        S.top = S.base;
    }
    return OK;
}
```

4. 销毁栈

```c
Status DestoryStack(SqStack &S){
    if(S.base){
        delete S.base;
        S.stacksize = 0;
        S.top = S.base = NULL;
    }
    return OK;
}
```

#### 算法3.2 顺序栈的入栈

【算法步骤】

1. 判断栈是否满，若栈满则返回ERROR
2. 将新元素压入栈顶，栈顶指针加一

【算法描述】

```c
Status push(SqStack &S, SElemType e){
    if(S.top - S.base == S.stacksize){
        return ERROR;
    }
    *S.top = e;
    top ++;
    return OK;
}
```

#### 算法3.3 顺序栈的出栈

【算法步骤】

1. 判断栈是否为空，为空返回ERROR
2. 栈顶指针减一，栈顶元素出栈

【算法描述】

```c
Status Pop(SqStack &S, SElemType e){
    if(S.top == S.base){
        return ERROR;
    }
    S.top--;
    e = *S.top;
    return OK;
}
```

#### 算法3.4 区栈顶元素

【算法描述】

```c
SElemType GetTop(SqStack S){
    if(S.top != S.base){
        return *(--S.top);
    }
}
```

### 链栈的表示和实现

**链栈** 是指采用链式存储结构的栈。

链栈结构的定义：

```c
//-----链栈的存储结构-----
typedef struct StackNode{
    ElemType data;
    struct StackNode *next;
}StackNode,*LinkStack;
```

**说明**

和链表相同，这里StackNode和*LinkStack本质上是一样的，习惯上使用StackNode 来定义结点，使用LinkStack来定义链表。

#### 算法3.5 链栈的初始化

【算法步骤】

链栈的初始化就是构造一个空栈，由于没有必要设头节点，所以直接将栈顶指针置空即可。

【算法描述】

```c
Status InitStack(LinkStack &S){
    S = NULL;
    return OK;
}
```

#### 算法3.6 链栈的入栈

【算法步骤】

1. 为入栈元素e分配空间，用指针p指向
2. 将新结点的数据域置为e
3. 将新结点插入栈顶
4. 修改栈顶指针为p

【算法描述】

```c
Status Push(LinkStack &S,SElemType e){
    p = new StackNode;
    p -> data = e;
    p -> next = S;
    S = p;
    return OK;
}
```

#### 算法3.7 链栈的出栈

【算法步骤】

1. 判断栈是否为空，若空则返回ERROR
2. 将栈顶元素赋值给e
3. 临时保存栈顶元素的空间，以备释放
4. 修改栈顶指针，指向新的栈顶元素
5. 释放原栈顶元素的空间

【算法描述】

```c
Status Pop(LinkStack &S, SElemType &e){
    if (S = NULL){
        return ERROR;
    }
    e = S -> data;
    p = S;    //用p临时保存栈顶元素空间，以备释放
    S = S -> next;
    delete p;
    return OK;
}
```

#### 算法3.8 取栈顶元素

【算法描述】

```c
SElemType GetTop(LinkStack S){
    if(S != NULL){
        return S -> data;
    }
}
```



